oop notes

জাভাস্ক্রিপ্টে অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP): কোডকে বাস্তবের মত করে গড়ে তোলা
তুমি একজন আর্কিটেক্ট, এবং তোমাকে একটি আধুনিক আবাসিক কমপ্লেক্স ডিজাইন করতে বলা হয়েছে। তুমি কি প্রতিটি অ্যাপার্টমেন্টের জন্য আলাদা করে প্রতিটি জানালা, প্রতিটি দরজা, প্রতিটি দেয়াল নতুন করে আঁকবে? না! তুমি একটি ব্লুপ্রিন্ট তৈরি করবে একটি আদর্শ অ্যাপার্টমেন্টের জন্য। এই ব্লুপ্রিন্টে থাকবে অ্যাপার্টমেন্টে কী কী থাকবে (বৈশিষ্ট্য - যেমন বেডরুমের সংখ্যা, বাথরুমের সংখ্যা) এবং সেখানে কী কী করা যাবে (কর্মক্ষমতা - যেমন দরজা খোলা/বন্ধ করা, আলো জ্বালানো/নেভানো)। একবার এই ব্লুপ্রিন্ট তৈরি হয়ে গেলে, তুমি সেই ব্লুপ্রিন্ট ব্যবহার করে যত খুশি অ্যাপার্টমেন্ট তৈরি করতে পারবে, প্রত্যেকেই তাদের নিজস্ব সেট বৈশিষ্ট্য এবং কর্মক্ষমতা নিয়ে।

OOP ঠিক এই ধারণার উপর ভিত্তি করে কাজ করে। এটি হলো একটি প্রোগ্রামিং প্যারাডাইম যা অবজেক্ট ধারণার উপর ভিত্তি করে কোডকে সংগঠিত করে। এটি বাস্তব বিশ্বের সত্তাগুলোকে (entities) মডেল করে, যেখানে প্রতিটি সত্তার নিজস্ব ডেটা (properties) এবং সেই ডেটার উপর কাজ করার জন্য নিজস্ব ফাংশন (methods) থাকে।

জাভাস্ক্রিপ্ট একটি মাল্টি-প্যারাডাইম ল্যাঙ্গুয়েজ। এর মানে হলো, তুমি এতে ফাংশনাল প্রোগ্রামিং, ইম্পেরেটিভ প্রোগ্রামিং এবং অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং - সবই করতে পারো। যদিও জাভাস্ক্রিপ্ট প্রোটোটাইপ-ভিত্তিক (prototype-based) OOP ব্যবহার করে, ES6 (ECMAScript 2015) থেকে class কীওয়ার্ড যোগ হওয়ার পর এটি অন্যান্য ক্লাস-ভিত্তিক (class-based) ভাষার মতো দেখতে লাগে, যা OOP কে আরও সহজবোধ্য করেছে।

OOP এর চারটি স্তম্ভ (Four Pillars of OOP)
OOP এর প্রধানত চারটি মূল ধারণা রয়েছে, যা একে শক্তিশালী এবং কার্যকরী করে তোলে:

এনক্যাপসুলেশন (Encapsulation): ডেটা এবং সেই ডেটার উপর কাজ করা ফাংশনগুলোকে একটি একক ইউনিটের (যেমন: একটি ক্লাস বা অবজেক্ট) মধ্যে আবদ্ধ করা। এটি বাইরের কোড থেকে ডেটার সরাসরি অ্যাক্সেসকে নিয়ন্ত্রণ করে, যা ডেটার নিরাপত্তা নিশ্চিত করে।

রূপক: একটি গাড়ির ইঞ্জিন। ইঞ্জিনের ভেতরের জটিল যন্ত্রাংশগুলো তুমি বাইরে থেকে দেখতে পাও না, সেগুলো একটি ধাতব খাপের মধ্যে আবদ্ধ থাকে। তুমি শুধু নির্দিষ্ট ইন্টারফেস (যেমন: ইগনিশন, এক্সিলারেটর) ব্যবহার করে এটিকে নিয়ন্ত্রণ করো। ভেতরের কার্যকারিতা লুকিয়ে রাখা (data hiding) এবং একটি নিয়ন্ত্রিত ইন্টারফেসের মাধ্যমে অ্যাক্সেস দেওয়াটাই এনক্যাপসুলেশন।

অ্যাবস্ট্রাকশন (Abstraction): শুধুমাত্র প্রয়োজনীয় তথ্য প্রকাশ করা এবং অপ্রয়োজনীয় বিশদ গোপন করা। ব্যবহারকারীকে একটি উচ্চ-স্তরের দৃশ্য দেওয়া হয়, যেখানে অভ্যন্তরীণ জটিলতাগুলো আড়াল করা হয়।

রূপক: একটি টিভি রিমোট। তুমি যখন রিমোটের 'ভলিউম আপ' বোতাম চাপো, তখন ভলিউম বাড়ে। ভেতরের সার্কিট কিভাবে কাজ করে বা কোন সিগন্যাল টিভিতে যায়, তা তোমার জানার দরকার নেই। তুমি শুধু জানো যে এই বোতামটি এই কাজটি করে।

ইনহেরিটেন্স (Inheritance): একটি ক্লাসকে (Parent/Base Class) অন্য ক্লাস থেকে (Child/Derived Class) বৈশিষ্ট্য এবং পদ্ধতি উত্তরাধিকার সূত্রে পেতে দেওয়া। এটি কোড পুনরায় ব্যবহার করতে এবং একটি শ্রেণিবদ্ধ সম্পর্ক তৈরি করতে সাহায্য করে।

রূপক: পারিবারিক উত্তরাধিকার। একজন ছেলে তার বাবার কাছ থেকে কিছু বৈশিষ্ট্য (যেমন: চুলের রঙ, চোখের রঙ) এবং কিছু পেশা (যেমন: বাবা যদি ডাক্তার হন, ছেলেও ডাক্তার হতে পারে) উত্তরাধিকার সূত্রে পায়। ছেলের নিজস্ব কিছু নতুন বৈশিষ্ট্যও থাকতে পারে।

পলিমরফিজম (Polymorphism): "অনেক রূপ" এর ক্ষমতা। এটি একই ফাংশন বা মেথডকে বিভিন্ন ধরনের অবজেক্টের জন্য ভিন্ন ভিন্ন আচরণ করতে সক্ষম করে তোলে।

রূপক: একজন ব্যক্তি। একই ব্যক্তি পরিবারের জন্য বাবা/মা, কর্মক্ষেত্রে বস/কর্মী, বন্ধুদের জন্য বন্ধু। একই ব্যক্তি কিন্তু ভিন্ন পরিস্থিতিতে ভিন্ন ভূমিকা পালন করে। OOP তে, একটি মেথডের একই নাম থাকতে পারে, কিন্তু ভিন্ন ক্লাসে এটি ভিন্ন কাজ করতে পারে।

জাভাস্ক্রিপ্টে OOP এর বাস্তবায়ন: class এর মাধ্যমে
ES6 এর class সিনট্যাক্টিক সুগার হলেও, এটি প্রোটোটাইপ-ভিত্তিক ইনহেরিটেন্সকে আরও সহজবোধ্য করে তোলে। চলো আমাদের "আর্কিটেক্ট" রূপকটি ব্যবহার করে class এর মাধ্যমে OOP ধারণাগুলো শিখি।

ক্লাস (Class): ব্লুপ্রিন্ট তৈরি করা
একটি ক্লাস হলো একটি ব্লুপ্রিন্ট বা টেমপ্লেট যা থেকে অবজেক্ট তৈরি হয়। এটি কোনো ডেটা নয়, বরং ডেটা এবং ফাংশনের কাঠামো।

উদাহরণ 1: Apartment ক্লাস তৈরি করা

ধরি, তুমি একটি আবাসিক কমপ্লেক্সের জন্য অ্যাপার্টমেন্টের ব্লুপ্রিন্ট তৈরি করছো।



// Apartment.js - Apartment ক্লাসের ব্লুপ্রিন্ট

class Apartment {
  // constructor: যখন একটি নতুন Apartment অবজেক্ট তৈরি হয়, তখন এটি কল হয়।
  // এটি অবজেক্টের প্রাথমিক বৈশিষ্ট্য (properties) সেট করে।
  constructor(bedrooms, bathrooms, areaSqFt, floor) {
    this.bedrooms = bedrooms;       // বেডরুমের সংখ্যা
    this.bathrooms = bathrooms;     // বাথরুমের সংখ্যা
    this.areaSqFt = areaSqFt;       // আয়তন বর্গফুট
    this.floor = floor;             // ফ্লোর নাম্বার
    this.isOccupied = false;        // প্রাথমিকভাবে খালি থাকে
  }

  // Method: অ্যাপার্টমেন্টের তথ্য প্রদান করে
  getDetails() {
    return `এই অ্যাপার্টমেন্টে ${this.bedrooms}টি বেডরুম, ${this.bathrooms}টি বাথরুম, ${this.areaSqFt} বর্গফুট আয়তন এবং এটি ${this.floor} তলায় অবস্থিত।`;
  }

  // Method: অ্যাপার্টমেন্ট দখল করা (isOccupied স্টেটাস পরিবর্তন)
  occupy() {
    if (!this.isOccupied) {
      this.isOccupied = true;
      console.log(`অ্যাপার্টমেন্টটি এখন দখলকৃত।`);
    } else {
      console.log(`অ্যাপার্টমেন্টটি ইতিমধ্যেই দখলকৃত।`);
    }
  }

  // Method: অ্যাপার্টমেন্ট খালি করা
  vacate() {
    if (this.isOccupied) {
      this.isOccupied = false;
      console.log(`অ্যাপার্টমেন্টটি এখন খালি।`);
    } else {
      console.log(`অ্যাপার্টমেন্টটি ইতিমধ্যেই খালি।`);
    }
  }
}

// export default Apartment; // মডিউল হিসেবে এক্সপোর্ট করতে চাইলে




নোট:

class কীওয়ার্ড: একটি ক্লাস ডিফাইন করতে ব্যবহৃত হয়।

constructor মেথড: এটি একটি বিশেষ মেথড। যখন new কীওয়ার্ড ব্যবহার করে একটি নতুন অবজেক্ট তৈরি হয়, তখন এই মেথডটি স্বয়ংক্রিয়ভাবে কল হয়। এর কাজ হলো নতুন তৈরি হওয়া অবজেক্টের প্রাথমিক প্রোপার্টিগুলো সেট করা।

this কীওয়ার্ড: ক্লাসের ভেতরে this কীওয়ার্ড অবজেক্টের নিজস্ব ইনস্ট্যান্সকে (instance) বোঝায়। this.bedrooms মানে এই নির্দিষ্ট Apartment অবজেক্টের bedrooms প্রোপার্টি।

মেথড: ক্লাসের ভেতরে সংজ্ঞায়িত ফাংশনগুলোকে মেথড বলা হয়।

অবজেক্ট (Object/Instance): ব্লুপ্রিন্ট থেকে বিল্ডিং তৈরি করা
ক্লাস হলো ব্লুপ্রিন্ট। যখন তুমি সেই ব্লুপ্রিন্ট ব্যবহার করে একটি বাস্তব জিনিস তৈরি করো, তখন তাকে একটি অবজেক্ট বা ইনস্ট্যান্স বলে।

উদাহরণ 2: Apartment ক্লাস থেকে অবজেক্ট তৈরি করা

আমাদের Apartment ব্লুপ্রিন্ট থেকে এখন কিছু বাস্তব অ্যাপার্টমেন্ট তৈরি করি।

// অন্য কোনো ফাইল, যেমন main.js

// import Apartment from './Apartment.js'; // যদি মডিউল হিসেবে ইম্পোর্ট করো

const apt101 = new Apartment(2, 1, 900, 1); // 2 বেড, 1 বাথ, 900 বর্গফুট, 1ম তলা
const apt203 = new Apartment(3, 2, 1200, 2); // 3 বেড, 2 বাথ, 1200 বর্গফুট, 2য় তলা
const apt305 = new Apartment(4, 3, 1800, 3); // 4 বেড, 3 বাথ, 1800 বর্গফুট, 3য় তলা

console.log("--- আমাদের অ্যাপার্টমেন্টগুলো ---");
console.log(apt101.getDetails()); // আউটপুট: এই অ্যাপার্টমেন্টে 2টি বেডরুম, 1টি বাথরুম, 900 বর্গফুট আয়তন এবং এটি 1 তলায় অবস্থিত।
console.log(apt203.getDetails()); // আউটপুট: এই অ্যাপার্টমেন্টে 3টি বেডরুম, 2টি বাথরুম, 1200 বর্গফুট আয়তন এবং এটি 2 তলায় অবস্থিত।

console.log("\n--- অ্যাপার্টমেন্টের অবস্থা ---");
console.log(`অ্যাপার্টমেন্ট 101 দখলকৃত? ${apt101.isOccupied}`); // আউটপুট: অ্যাপার্টমেন্ট 101 দখলকৃত? false

apt101.occupy(); // অ্যাপার্টমেন্ট 101 দখল করো
console.log(`অ্যাপার্টমেন্ট 101 দখলকৃত? ${apt101.isOccupied}`); // আউটপুট: অ্যাপার্টমেন্ট 101 দখলকৃত? true

apt203.occupy(); // অ্যাপার্টমেন্ট 203 দখল করো
apt203.occupy(); // আবার দখল করার চেষ্টা

নোট:

new কীওয়ার্ড: একটি ক্লাসের নতুন ইনস্ট্যান্স (অবজেক্ট) তৈরি করতে new কীওয়ার্ড ব্যবহৃত হয়।

প্রতিটি তৈরি হওয়া অবজেক্ট apt101, apt203, apt305 হলো Apartment ক্লাসের একটি স্বতন্ত্র কপি। তাদের প্রত্যেকের নিজস্ব bedrooms, bathrooms, areaSqFt, floor এবং isOccupied প্রোপার্টি আছে, কিন্তু তারা একই getDetails, occupy, vacate মেথড শেয়ার করে।

এনক্যাপসুলেশন (Encapsulation): ডেটা ও মেথডকে একসাথে রাখা
এনক্যাপসুলেশন হলো ডেটা (properties) এবং সেই ডেটার উপর কাজ করার জন্য মেথডগুলোকে একটি একক ইউনিটের (ক্লাসের) মধ্যে আবদ্ধ করা। এটি ডেটাকে সুরক্ষিত রাখে এবং ডেটার অ্যাক্সেস নিয়ন্ত্রণ করে।

উদাহরণ 3: Car ক্লাসে এনক্যাপসুলেশন

ধরো, তুমি একটি গাড়ির ব্লুপ্রিন্ট তৈরি করছো। গাড়ির ইঞ্জিন, চাকা, জ্বালানি - এগুলো তার ভেতরের ডেটা। কিন্তু একজন ব্যবহারকারী কি সরাসরি ইঞ্জিনের ভেতরের পার্টস নিয়ন্ত্রণ করে? না। সে স্টিয়ারিং, এক্সিলারেটর, ব্রেক ব্যবহার করে।

// Car.js - Car ক্লাসের ব্লুপ্রিন্ট (এনক্যাপসুলেশন)

class Car {
  #fuelLevel = 100; // প্রাইভেট প্রোপার্টি: ES2020 থেকে `#` দিয়ে প্রাইভেট প্রোপার্টি ডিফাইন করা যায়।
                   // এটি সরাসরি বাইরে থেকে অ্যাক্সেস করা যাবে না।
  #engineOn = false;

  constructor(make, model) {
    this.make = make;
    this.model = model;
    console.log(`${make} ${model} তৈরি হলো।`);
  }

  // মেথড: গাড়ি স্টার্ট করা
  startEngine() {
    if (this.#fuelLevel > 0 && !this.#engineOn) {
      this.#engineOn = true;
      console.log(`${this.make} ${this.model} এর ইঞ্জিন স্টার্ট হলো।`);
    } else if (this.#engineOn) {
      console.log(`ইঞ্জিন ইতিমধ্যেই স্টার্ট করা আছে।`);
    } else {
      console.log(`জ্বালানি নেই!`);
    }
  }

  // মেথড: গাড়ি বন্ধ করা
  stopEngine() {
    if (this.#engineOn) {
      this.#engineOn = false;
      console.log(`${this.make} ${this.model} এর ইঞ্জিন বন্ধ হলো।`);
    } else {
      console.log(`ইঞ্জিন ইতিমধ্যেই বন্ধ আছে।`);
    }
  }

  // মেথড: জ্বালানি চেক করা (এনক্যাপসুলেটেড ডেটা অ্যাক্সেসের জন্য গেটার)
  getFuelLevel() {
    return this.#fuelLevel;
  }

  // মেথড: জ্বালানি ভরা (এনক্যাপসুলেটেড ডেটা পরিবর্তনের জন্য সেটার)
  refuel(amount) {
    if (amount > 0) {
      this.#fuelLevel = Math.min(100, this.#fuelLevel + amount);
      console.log(`জ্বালানি ভরা হলো। বর্তমান স্তর: ${this.#fuelLevel}%`);
    }
  }
}

// --- ব্যবহার ---
const myCar = new Car("Toyota", "Corolla");

// myCar.#fuelLevel; // এটি সরাসরি অ্যাক্সেস করতে পারবে না, এরর দেবে!

myCar.startEngine(); // ইঞ্জিন স্টার্ট করার চেষ্টা
myCar.refuel(50);    // জ্বালানি ভরো
myCar.startEngine(); // এখন স্টার্ট হবে

console.log(`আমার গাড়ির জ্বালানি স্তর: ${myCar.getFuelLevel()}%`);

myCar.stopEngine();
myCar.startEngine(); // আবার স্টার্ট করার চেষ্টা









এই উদাহরণে, fuelLevel এবং engineOn প্রোপার্টিগুলো # দিয়ে প্রাইভেট করা হয়েছে। এর মানে হলো, তুমি ক্লাসের বাইরে থেকে সরাসরি myCar.#fuelLevel = 0; লিখতে পারবে না। তোমাকে refuel() এবং getFuelLevel() এর মতো পাবলিক মেথডগুলো ব্যবহার করে ডেটা অ্যাক্সেস বা পরিবর্তন করতে হবে। এটিই এনক্যাপসুলেশন, যা ডেটার সুরক্ষা বাড়ায়।

ইনহেরিটেন্স (Inheritance): ব্লুপ্রিন্ট থেকে বিশেষায়িত ব্লুপ্রিন্ট তৈরি করা
ইনহেরিটেন্স হলো যখন একটি ক্লাস (Child Class) অন্য একটি ক্লাস (Parent/Base Class) থেকে প্রোপার্টি এবং মেথড উত্তরাধিকার সূত্রে পায়। এটি কোড পুনরায় ব্যবহার করতে সাহায্য করে এবং বস্তুর মধ্যে "is-a" (এটি একটি) সম্পর্ক স্থাপন করে।

উদাহরণ 4: Building এবং CommercialBuilding ক্লাসের ইনহেরিটেন্স

ধরি, তুমি Building নামে একটি সাধারণ ব্লুপ্রিন্ট তৈরি করেছ। এখন, তুমি CommercialBuilding নামে একটি বিশেষ ধরনের বিল্ডিং তৈরি করতে চাও, যার কিছু অতিরিক্ত বৈশিষ্ট্য থাকবে (যেমন দোকানের সংখ্যা, অফিসের সংখ্যা)।

// Building.js - সাধারণ বিল্ডিং ব্লুপ্রিন্ট (Parent Class)

class Building {
  constructor(name, floors, areaSqFt) {
    this.name = name;
    this.floors = floors;
    this.areaSqFt = areaSqFt;
    this.isConstructed = false;
  }

  // মেথড: বিল্ডিংয়ের তথ্য প্রদান
  getBuildingInfo() {
    return `${this.name} বিল্ডিংয়ে ${this.floors}টি ফ্লোর আছে এবং এর আয়তন ${this.areaSqFt} বর্গফুট।`;
  }

  // মেথড: নির্মাণ সম্পন্ন করা
  completeConstruction() {
    if (!this.isConstructed) {
      this.isConstructed = true;
      console.log(`${this.name} নির্মাণ সম্পন্ন হয়েছে।`);
    } else {
      console.log(`${this.name} ইতিমধ্যেই নির্মিত।`);
    }
  }
}

// CommercialBuilding.js - CommercialBuilding ক্লাসের ব্লুপ্রিন্ট (Child Class)
// এটি Building ক্লাস থেকে ইনহেরিট করছে

class CommercialBuilding extends Building { // 'extends' কীওয়ার্ড ব্যবহার করে ইনহেরিট করা হয়
  constructor(name, floors, areaSqFt, numberOfShops, numberOfOffices) {
    // super(): প্যারেন্ট ক্লাসের constructor কল করে তার প্রোপার্টিগুলো ইনিশিয়ালাইজ করে।
    // Child ক্লাসে constructor থাকলে super() অবশ্যই ব্যবহার করতে হবে এবং সবার আগে কল করতে হবে।
    super(name, floors, areaSqFt);

    this.numberOfShops = numberOfShops;
    this.numberOfOffices = numberOfOffices;
  }

  // মেথড: কমার্শিয়াল বিল্ডিংয়ের অতিরিক্ত তথ্য
  getCommercialInfo() {
    return `${this.name} এ ${this.numberOfShops}টি দোকান এবং ${this.numberOfOffices}টি অফিস আছে।`;
  }

  // Method Overriding (পলিমরফিজমের একটি অংশ):
  // প্যারেন্ট ক্লাসের মেথডকে চাইল্ড ক্লাসে নিজের মতো করে পরিবর্তন করা।
  getBuildingInfo() {
    const baseInfo = super.getBuildingInfo(); // super.method() দিয়ে প্যারেন্ট মেথড কল করা যায়
    return `${baseInfo} এটি একটি বাণিজ্যিক ভবন।`;
  }
}

// --- ব্যবহার ---
const residentialComplex = new Building("আবাসিক কমপ্লেক্স", 10, 50000);
console.log(residentialComplex.getBuildingInfo());
residentialComplex.completeConstruction();

const shoppingMall = new CommercialBuilding("সিটি সেন্টার মল", 5, 80000, 150, 20);
console.log(shoppingMall.getBuildingInfo()); // এখানে ওভাররাইড করা মেথড কল হচ্ছে
console.log(shoppingMall.getCommercialInfo());
shoppingMall.completeConstruction(); // প্যারেন্ট ক্লাস থেকে উত্তরাধিকার সূত্রে প্রাপ্ত মেথড


নোট:

extends কীওয়ার্ড: একটি ক্লাস অন্য ক্লাস থেকে উত্তরাধিকার সূত্রে পেতে extends ব্যবহার করে।

super() কীওয়ার্ড: চাইল্ড ক্লাসের constructor-এর ভেতরে super() কল করা বাধ্যতামূলক, যদি চাইল্ড ক্লাসের নিজস্ব constructor থাকে। এটি প্যারেন্ট ক্লাসের constructor কল করে এবং প্যারেন্ট ক্লাসের প্রোপার্টিগুলো ইনিশিয়ালাইজ করে।

মেথড ওভাররাইডিং: যদি চাইল্ড ক্লাসে প্যারেন্ট ক্লাসের মতো একই নামের কোনো মেথড ডিফাইন করা হয়, তাহলে চাইল্ড ক্লাসের মেথডটি কার্যকর হবে। তুমি super.methodName() ব্যবহার করে প্যারেন্ট ক্লাসের মূল মেথডটি চাইল্ড ক্লাসের মেথডের ভেতরে কল করতে পারো।

পলিমরফিজম (Polymorphism): অনেক রূপের ক্ষমতা
পলিমরফিজম মানে "অনেক রূপ"। OOP-এ এর মানে হলো, ভিন্ন ভিন্ন অবজেক্ট একই নামের মেথড কল করার পরেও ভিন্ন ভিন্ন আচরণ করতে পারে। এটি মূলত ইনহেরিটেন্স এবং মেথড ওভাররাইডিং এর মাধ্যমে অর্জন করা হয়।
উদাহরণ 5: Vehicle এবং তার থেকে প্রাপ্ত ক্লাসগুলোতে পলিমরফিজম

ধরো, তোমার কাছে বিভিন্ন ধরণের যানবাহন আছে: গাড়ি, বাইক, প্লেন। প্রত্যেকেই "চালনা" করতে পারে, কিন্তু তাদের চালনার পদ্ধতি ভিন্ন।

// Vehicle.js - সাধারণ যানবাহন ব্লুপ্রিন্ট (Base Class)

class Vehicle {
  constructor(brand) {
    this.brand = brand;
  }

  // মেথড: যানটিকে চালনা করা
  drive() {
    console.log(`${this.brand} চলছে... (সাধারণ চালনা)`);
  }
}

// Car.js - গাড়ি ব্লুপ্রিন্ট
class Car extends Vehicle {
  constructor(brand, model) {
    super(brand);
    this.model = model;
  }

  // মেথড ওভাররাইড: গাড়ির জন্য ভিন্নভাবে চালনা
  drive() {
    console.log(`${this.brand} ${this.model} হাইওয়েতে দ্রুত গতিতে চলছে!`);
  }
}

// Bicycle.js - বাইসাইকেল ব্লুপ্রিন্ট
class Bicycle extends Vehicle {
  constructor(brand, type) {
    super(brand);
    this.type = type;
  }

  // মেথড ওভাররাইড: বাইসাইকেলের জন্য ভিন্নভাবে চালনা
  drive() {
    console.log(`${this.brand} ${this.type} প্যাডেল করে চলছে।`);
  }
}

// Airplane.js - বিমান ব্লুপ্রিন্ট
class Airplane extends Vehicle {
  constructor(brand, airline) {
    super(brand);
    this.airline = airline;
  }

  // মেথড ওভাররাইড: প্লেনের জন্য ভিন্নভাবে চালনা
  drive() { // যদিও প্লেন আকাশে ওড়ে, আমরা সিম্পলিসিটির জন্য drive ব্যবহার করছি
    console.log(`${this.brand} ${this.airline} আকাশপথে উড়ছে!`);
  }
}

// --- ব্যবহার (পলিমরফিজম) ---

const myCar = new Car("Honda", "Civic");
const myBicycle = new Bicycle("Hero", "Mountain Bike");
const myAirplane = new Airplane("Boeing", "Biman Bangladesh Airlines");
const unknownVehicle = new Vehicle("Generic");

const vehicles = [myCar, myBicycle, myAirplane, unknownVehicle];

console.log("\n--- বিভিন্ন যান চালনা ---");
vehicles.forEach(vehicle => {
  vehicle.drive(); // একই 'drive()' মেথড কল করা হচ্ছে, কিন্তু প্রতিটি অবজেক্ট ভিন্ন আচরণ করছে
});

/* আউটপুট:
Honda Civic হাইওয়েতে দ্রুত গতিতে চলছে!
Hero Mountain Bike প্যাডেল করে চলছে।
Boeing Biman Bangladesh Airlines আকাশপথে উড়ছে!
Generic চলছে... (সাধারণ চালনা)
*/

এই উদাহরণে, vehicles অ্যারেতে ভিন্ন ভিন্ন ক্লাসের (Car, Bicycle, Airplane, Vehicle) অবজেক্ট রয়েছে। কিন্তু যখন আমরা লুপের মধ্যে vehicle.drive() কল করি, তখন প্রতিটি অবজেক্ট তার নিজস্ব drive() মেথড চালায়। এটিই পলিমরফিজম – একই মেথড কল ভিন্ন ভিন্ন অবজেক্টে ভিন্ন ফলাফল দিচ্ছে।

অ্যাবস্ট্রাকশন (Abstraction): অপ্রয়োজনীয় বিশদ গোপন করা
অ্যাবস্ট্রাকশন হলো ব্যবহারকারীর কাছে শুধুমাত্র প্রয়োজনীয় ফাংশনালিটি প্রকাশ করা এবং অভ্যন্তরীণ জটিলতা গোপন রাখা। জাভাস্ক্রিপ্টে অ্যাবস্ট্রাকশন সরাসরি 'অ্যাবস্ট্রাক্ট ক্লাস' দিয়ে বাস্তবায়ন করা হয় না (যেমন জাভা বা C++ এ হয়), তবে ক্লাস, মডিউল এবং প্রাইভেট প্রোপার্টির মাধ্যমে এটি অর্জন করা যায়।

উদাহরণ 6: একটি MediaPlayer ক্লাসে অ্যাবস্ট্রাকশন

ধরো, তুমি একটি মিডিয়া প্লেয়ার তৈরি করছো। একজন ব্যবহারকারী শুধু জানে সে 'প্লে' বা 'পজ' বাটনে ক্লিক করতে পারে। প্লেয়ারের ভেতরের অডিও ডিকোডিং, বাফারিং, বা ফাইল লোডিংয়ের জটিলতা তার জানার দরকার নেই।

// MediaPlayer.js - মিডিয়া প্লেয়ারের ব্লুপ্রিন্ট (অ্যাবস্ট্রাকশন)

class MediaPlayer {
  #currentTrack = null;
  #isPlaying = false;
  #volume = 50; // 0-100

  // প্রাইভেট মেথড: বাইরে থেকে সরাসরি কল করা যাবে না
  #loadAudioFile(trackName) {
    console.log(`(অভ্যন্তরীণ) ${trackName} লোড করা হচ্ছে...`);
    // এখানে ফাইল লোডিং, ডিকোডিং ইত্যাদির জটিল লজিক থাকবে
    this.#currentTrack = trackName;
  }

  #decodeAudio() {
    console.log(`(অভ্যন্তরীণ) অডিও ডিকোড করা হচ্ছে...`);
    // অডিও ডিকোডিং লজিক
  }

  constructor(playerType) {
    this.playerType = playerType;
    console.log(`${playerType} মিডিয়া প্লেয়ার তৈরি হলো।`);
  }

  // পাবলিক মেথড: ব্যবহারকারী এইগুলোই ব্যবহার করবে
  play(trackName) {
    if (this.#isPlaying) {
      console.log(`ইতিমধ্যেই ${this.#currentTrack} চলছে।`);
      return;
    }
    this.#loadAudioFile(trackName); // অভ্যন্তরীণ মেথড ব্যবহার করা হচ্ছে
    this.#decodeAudio();            // অভ্যন্তরীণ মেথড ব্যবহার করা হচ্ছে
    this.#isPlaying = true;
    console.log(`▶️ এখন চলছে: ${this.#currentTrack}`);
  }

  pause() {
    if (this.#isPlaying) {
      this.#isPlaying = false;
      console.log(`⏸️ ${this.#currentTrack} পজ করা হলো।`);
    } else {
      console.log(`কোনো গান চলছে না।`);
    }
  }

  setVolume(level) {
    this.#volume = Math.max(0, Math.min(100, level));
    console.log(`ভলিউম সেট করা হলো: ${this.#volume}`);
  }

  getCurrentTrack() {
    return this.#currentTrack;
  }
}

// --- ব্যবহার ---
const musicPlayer = new MediaPlayer("পোর্টেবল");

musicPlayer.play("শাওন গানওয়ালা - ইচ্ছেঘুড়ি");
musicPlayer.setVolume(75);
musicPlayer.pause();
musicPlayer.play("আর্টসেল - অন্য সময়");

// musicPlayer.#loadAudioFile("লুকানো গান"); // এরর দেবে! প্রাইভেট মেথড অ্যাক্সেস করা যাবে না।
// musicPlayer.#isPlaying = true; // এরর দেবে! প্রাইভেট প্রোপার্টি অ্যাক্সেস করা যাবে না।

এই উদাহরণে, MediaPlayer ক্লাসের #loadAudioFile এবং #decodeAudio মেথডগুলো প্রাইভেট করা হয়েছে। ব্যবহারকারী (বা ক্লাসের বাইরের কোড) এই অভ্যন্তরীণ জটিলতাগুলো নিয়ে চিন্তা করে না। সে শুধু play(), pause(), setVolume() - এই পাবলিক ইন্টারফেসগুলো ব্যবহার করে প্লেয়ার নিয়ন্ত্রণ করে। এটিই অ্যাবস্ট্রাকশন – অপ্রয়োজনীয় বিশদ গোপন রেখে সহজবোধ্য ইন্টারফেস প্রদান করা।


OOP এর সুবিধা:
মডুলারিটি (Modularity): কোডকে ছোট ছোট, স্বাধীন ইউনিটে (অবজেক্ট) ভাগ করা যায়।

পুনঃব্যবহারযোগ্যতা (Reusability): ক্লাস এবং ইনহেরিটেন্স ব্যবহার করে কোড পুনরায় ব্যবহার করা যায়, যা ডেভেলপমেন্ট টাইম বাঁচায়।

সহজ রক্ষণাবেক্ষণ (Maintainability): প্রতিটি অবজেক্ট একটি নির্দিষ্ট কাজ করে, তাই কোডে পরিবর্তন বা বাগ ফিক্স করা সহজ হয়।

বর্ধনযোগ্যতা (Scalability): নতুন ফিচার বা ফাংশনালিটি যোগ করা সহজ হয়, কারণ বিদ্যমান কোড পরিবর্তন না করেও নতুন ক্লাস যোগ করা যায়।

ডেটা সুরক্ষা: এনক্যাপসুলেশন ডেটার অননুমোদিত অ্যাক্সেস থেকে রক্ষা করে।

OOP কি সবসময় প্রয়োজন?
না। জাভাস্ক্রিপ্টে OOP খুবই শক্তিশালী, তবে এর অর্থ এই নয় যে প্রতিটি ছোট অ্যাপ্লিকেশনে এটি ব্যবহার করতেই হবে। ছোট বা সাধারণ কাজগুলোর জন্য ফাংশনাল প্রোগ্রামিং বা সাধারণ অবজেক্ট লিটারেলই যথেষ্ট হতে পারে। তবে, যখন একটি অ্যাপ্লিকেশন বড় এবং জটিল হয়, তখন OOP কোডকে আরও সুসংগঠিত, মডুলার এবং রক্ষণাবেক্ষণযোগ্য করতে দারুণ সাহায্য করে।

এই হলো জাভাস্ক্রিপ্টে OOP এর একটি বিস্তারিত ধারণা। তুমি এখন OOP এর চারটি স্তম্ভ এবং class সিনট্যাক্স ব্যবহার করে কীভাবে সেগুলো বাস্তবায়ন করা হয় তা সম্পর্কে একটি পরিষ্কার ধারণা পেয়েছ।

তোমার জাভাস্ক্রিপ্ট মাস্টারি যাত্রার এই ধাপটি খুব গুরুত্বপূর্ণ। এই ধারণাগুলো যত শক্তিশালী হবে, তত ভালো কোড তুমি লিখতে পারবে!

তোমার কোনো প্রশ্ন থাকলে জিজ্ঞাসা করতে পারো, বা যদি অন্য কোনো টপিক শুরু করতে চাও, আমাকে জানাও!

